---
format:
  html:
    fig-width: 10
  gfm:
    fig-width: 10
editor: 
  markdown: 
    wrap: sentence
---

## Datasets

```{r}
#| label: source config
#| include: FALSE
#| results: 'hide'
#| warning: FALSE
#| message: FALSE

library(here)

here::i_am("website/database_structure/_02_Datasets.qmd")

# Load configuration
source(
  here::here(
    "R/00_Config_file.R"
  )
)

source(
  here::here(
    "R/03_Visualisation/00_Config_quarto.R"
  )
)

invisible(
  lapply(
    list.files(
      path = here::here("R/Functions"),
      pattern = "*.R",
      recursive = TRUE,
      full.names = TRUE
    ),
    source
  )
)

sel_dataset_for_example <- 91256
```

### Dataset Structure Overview (`Datasets`)

The `Datasets` table represents the main organizational structure in **VegVault**, serving as the keystone for managing and organizing all data. Each Dataset contains one row with a unique Dataset ID (`dataset_id`), Dataset name (`dataset_name`), geographic location (`coord_lat`, `coord_long`), Dataset Type (`dataset_type_id`), Dataset Source (`data_source_id`), Dataset Source Type (`dataset_source_type_id`), and Sampling Method (`sampling_method_id`). 

```{r}
#| label: Datasets variables scheme structure
#| tbl-cap: "Column names and types for table Datasets."
data_comments_datasets <-
  tibble::tribble(
    ~column_name, ~description,
    "dataset_id", "ID of a Dataset (unique)",
    "dataset_name", "Name of each Dataset",
    "dataset_type_id", "ID of a Dataset Type",
    "data_source_id", "ID of a Dataset Source",
    "data_source_type_id", "ID of a Dataset Source-Type",
    "coord_long", "Geographical coordinates - longitude",
    "coord_lat", "Geographical coordinates - latitude",
    "sampling_method_id", "ID of a Sampling Method"
  )

get_db_table_data_types(
  con,
  "Datasets"
) %>%
  dplyr::full_join(
    data_comments_datasets,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset scheme structure
include_graphics_absolute_path(
  here::here(
    "Outputs/Figures/website/DB_scheme_visualisation/Datasets.png"
  )
)
```

#### Dataset Types (`DatasetTypeID`)

The `Dataset Type` defines the most basic classification of each `Dataset`, ensuring that the vast amount of data is categorized systematically. Currently, **VegVault** contains the following types of `Datasets`:

-	`vegetation_plot`: This type includes contemporary vegetation plot data, capturing contemporary vegetation characteristics and distributions.
-	`fossil_pollen_archive`: This type encompasses past vegetation plot data derived from fossil pollen records, providing insights into past vegetation and climate dynamics.
-	`traits`: This type contains functional trait data, detailing specific characteristics of plant species that influence their ecological roles.
-	`gridpoints`: This type holds artificially created `Datasets` to manage abiotic data, here climate and soil information (a dataset type created to hold abiotic data, see details in the Methods section).

```{r}
#| label: Dataset Type variables scheme structure
#| tbl-cap: "Column names and types for table DatasetTypeID."
data_comments_dataset_type <-
  tibble::tribble(
    ~column_name, ~description,
    "dataset_type_id", "ID of a Dataset Type (unique)",
    "dataset_type", "Text description of individual Dataset Types (currently vegetation_plot, fossil_pollen_archive, traits, gridpoints)"
  )

get_db_table_data_types(
  con,
  "DatasetTypeID"
) %>%
  dplyr::full_join(
    data_comments_dataset_type,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset Type scheme structure
include_graphics_absolute_path(
  here::here(
    "Outputs/Figures/website/DB_scheme_visualisation/DatasetTypeID.png"
  )
)
```

```{r}
#| label: Dataset type - plots
n_datasetes_per_type <-
  dplyr::inner_join(
    dplyr::tbl(con, "Datasets"),
    dplyr::tbl(con, "DatasetTypeID"),
    by = "dataset_type_id"
  ) %>%
  dplyr::group_by(dataset_type) %>%
  dplyr::count(name = "N") %>%
  dplyr::collect() %>%
  dplyr::ungroup()

fig_n_datasetes_per_type <-
  plot_waffle(
    n_datasetes_per_type,
    dataset_type,
    plot_title = "Dataset Type",
    one_point_is = 1e3
  ) +
  ggplot2::scale_fill_manual(
    values = palette_dataset_type
  )

save_figure_to_render(fig_n_datasetes_per_type)
```

#### Dataset Source-Types (`DatasetSourceTypeID`)

**VegVault** maintains detailed information about the primary data source, thereby enhancing the findability and referencing of primary data sources. Each `Dataset` is derived from a specific `Source-Type` that provides detailed information on the source used to retrieve the original data. The current `Source-Types` in **VegVault** include:

- **BIEN** - [Botanical Information and Ecology Network](https://bien.nceas.ucsb.edu/bien/)
- **sPlotOpen** - [The open-access version of sPlot](https://idiv-biodiversity.de/en/splot/splotopen.html)
- **TRY** - [TRY Plant Trait Database](https://www.try-db.org/TryWeb/Home.php)
- **FOSSILPOL** - [The workflow that aims to process and standardise global palaeoecological pollen data](https://hope-uib-bio.github.io/FOSSILPOL-website/). Note that we specifically state FOSSILPOL and not Neotoma, as FOSSILPOL not only provides the data acquisition but also alters it (e.g., creating new age-depth models). It also addresses major challenges in paleoecological data integration, such as age uncertainty, by incorporating probabilistic age-depth models and their associated uncertainty matrices. This enables the propagation of temporal uncertainty in subsequent analyses, a critical advancement for robust macroecological studies, previously flagged as a major issue with paleo-data.
- **gridpoints** - artificially created `Datasets` to hold abiotic data 

```{r}
#| label: Dataset Source Type variables scheme structure
#| tbl-cap: "Column names and types for table DatasetSourceTypeID."

data_comments_dataset_source_type <-
  tibble::tribble(
    ~column_name, ~description,
    "data_source_type_id", "ID of a Dataset Source-Type (unique)",
    "dataset_source_type", "Text description of individual Dataset Source-Type (currently, BEIN, sPlotOpen, TRY, Neotoma-FOSSILPOL, gridpoints)"
  )

get_db_table_data_types(
  con,
  "DatasetSourceTypeID"
) %>%
  dplyr::full_join(
    data_comments_dataset_source_type,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset Sources scheme structure
#| tbl-cap: "Column names and types for table DatasetSourceTypeReference."
data_comments_dataset_sources_type_reference <-
  tibble::tribble(
    ~column_name, ~description,
    "data_source_id", "ID of a Dataset Source",
    "reference_id", "ID of a Reference"
  )

get_db_table_data_types(
  con,
  "DatasetSourceTypeReference"
) %>%
  dplyr::full_join(
    data_comments_dataset_sources_type_reference,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset Source Type scheme structure
include_graphics_absolute_path(
  here::here(
    "Outputs/Figures/website/DB_scheme_visualisation/DatasetSourceTypeID.png"
  )
)
```

```{r}
#| label: dataset source type - plots
n_datasetes_per_type_per_source_type <-
  dplyr::inner_join(
    dplyr::tbl(con, "Datasets"),
    dplyr::tbl(con, "DatasetTypeID"),
    by = "dataset_type_id"
  ) %>%
  dplyr::inner_join(
    dplyr::tbl(con, "DatasetSourceTypeID"),
    by = "data_source_type_id"
  ) %>%
  dplyr::group_by(dataset_type, dataset_source_type) %>%
  dplyr::count(name = "N") %>%
  dplyr::collect() %>%
  dplyr::ungroup()

fig_n_datasetes_per_source_type <-
  n_datasetes_per_type_per_source_type %>%
  dplyr::group_by(dataset_type) %>%
  dplyr::mutate(
    n_datasetes_per_type = sum(N)
  ) %>%
  dplyr::ungroup() %>%
  dplyr::arrange(-n_datasetes_per_type, -N) %>%
  dplyr::mutate(
    dataset_type = factor(
      dataset_type,
      levels = unique(dataset_type)
    ),
    dataset_source_type = factor(
      dataset_source_type,
      levels = unique(dataset_source_type)
    )
  ) %>%
  ggplot2::ggplot(
    ggplot2::aes(
      y = N,
      x = dataset_source_type # reorder(dataset_source_type, -N)
    )
  ) +
  ggplot2::scale_y_continuous(
    transform = scales::transform_log10(),
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x)),
    limits = c(1, 10e6)
  ) +
  ggplot2::labs(
    title = "Dataset Type per Source-Type",
    x = "",
    y = "Number of Datasets"
  ) +
  ggplot2::theme(
    legend.position = "none",
    strip.text = ggplot2::element_text(colour = "white")
  ) +
  ggplot2::scale_fill_manual(
    values = palette_dataset_source_type
  ) +
  ggplot2::facet_wrap(~dataset_type, nrow = 1, scales = "free_x") +
  ggplot2::geom_segment(
    mapping = ggplot2::aes(
      x = dataset_source_type, # reorder(dataset_source_type, -N),
      xend = dataset_source_type, # reorder(dataset_source_type, -N),
      yend = 0
    ),
    color = col_blue_dark,
    position = ggplot2::position_dodge(0.5)
  ) +
  ggplot2::geom_point(
    mapping = ggplot2::aes(
      fill = dataset_source_type
    ),
    size = point_size,
    shape = 21,
    col = col_blue_dark,
    position = ggplot2::position_dodge(0.5)
  ) +
  ggplot2::geom_label(
    mapping = ggplot2::aes(
      label = scales::number(N)
    ),
    vjust = -0.5,
    size = point_size * 2,
    position = ggplot2::position_dodge(0.5)
  )

save_figure_to_render(fig_n_datasetes_per_source_type)
```

#### Dataset Sources (`DatasetSourcesID`)

Each individual `Dataset` from a specific `Dataset` `Source-Type` can have information on the source of the data (i.e. sub-database). **VegVault** v1.0.0 currently includes 706 sources of `Datasets`, where each dataset can also have one or more direct references to specific data, ensuring that users can accurately cite and verify the sources of their data. This should help to promote better findability of the primary source of data and referencing.

```{r}
#| label: Dataset Sources variables scheme structure
#| tbl-cap: "Column names and types for table DatasetSourcesID."
data_comments_dataset_sources <-
  tibble::tribble(
    ~column_name, ~description,
    "data_source_id", "ID of a Dataset Source (unique)",
    "data_source_desc", "Text description of individual Dataset Sources (e.g., name of the sub-database from the primary source)"
  )

get_db_table_data_types(
  con,
  "DatasetSourcesID"
) %>%
  dplyr::full_join(
    data_comments_dataset_sources,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset Sources Reference variables scheme structure
#| tbl-cap: "Column names and types for table DatasetSourcesReference."
data_comments_dataset_sources_reference <-
  tibble::tribble(
    ~column_name, ~description,
    "data_source_id", "ID of a Dataset Source",
    "reference_id", "ID of a Reference"
  )

get_db_table_data_types(
  con,
  "DatasetSourcesReference"
) %>%
  dplyr::full_join(
    data_comments_dataset_sources_reference,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset Source ID scheme structure
include_graphics_absolute_path(
  here::here(
    "Outputs/Figures/website/DB_scheme_visualisation/DatasetSourcesID.png"
  )
)
```

```{r}
#| label: Dataset ID
n_dataset_sources <-
  dplyr::inner_join(
    dplyr::tbl(con, "Datasets"),
    dplyr::tbl(con, "DatasetTypeID"),
    by = "dataset_type_id"
  ) %>%
  dplyr::inner_join(
    dplyr::tbl(con, "DatasetSourcesID"),
    by = "data_source_id"
  ) %>%
  dplyr::distinct(dataset_type, data_source_desc) %>%
  dplyr::group_by(dataset_type) %>%
  dplyr::count(name = "N") %>%
  dplyr::collect() %>%
  dplyr::ungroup()

n_total_sources <-
  sum(n_dataset_sources$N)

n_datasetes_per_source <-
  dplyr::inner_join(
    dplyr::tbl(con, "Datasets"),
    dplyr::tbl(con, "DatasetTypeID"),
    by = "dataset_type_id"
  ) %>%
  dplyr::inner_join(
    dplyr::tbl(con, "DatasetSourcesID"),
    by = "data_source_id"
  ) %>%
  dplyr::group_by(dataset_type, data_source_desc) %>%
  dplyr::count(name = "N") %>%
  dplyr::collect() %>%
  dplyr::ungroup() %>%
  tidyr::drop_na(data_source_desc)
```

Currently, there are `r n_total_sources` sources of datasets.

```{r}
#| label: Dataset ID - plots
fig_n_datasetes_per_source <-
  n_datasetes_per_source %>%
  ggplot2::ggplot(
    ggplot2::aes(
      x = dataset_type,
      y = N,
      fill = dataset_type
    )
  ) +
  ggplot2::geom_violin(
    col = NA
  ) +
  ggplot2::geom_boxplot(
    width = 0.2,
    fill = col_white,
    col = col_blue_dark,
    outlier.shape = NA
  ) +
  ggplot2::geom_point(
    data = n_datasetes_per_source %>%
      dplyr::group_by(dataset_type) %>%
      dplyr::summarise(
        N = median(N)
      ),
    mapping = ggplot2::aes(
      fill = dataset_type
    ),
    shape = 22,
    size = point_size
  ) +
  ggplot2::scale_y_continuous(
    transform = scales::transform_log10(),
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x))
  ) +
  ggplot2::labs(
    title = "Number of Datasets per Dataset Type",
    y = "Number of Datasets",
    x = ""
  ) +
  ggplot2::scale_fill_manual(
    values = palette_dataset_type
  ) +
  ggplot2::theme(
    legend.position = "none"
  )

save_figure_to_render(fig_n_datasetes_per_source)
```

#### Sampling Methods (`SamplingMethodID`)

Sampling methods vary significantly across the different types of `Datasets` integrated into **VegVault**, reflecting the diverse nature of the data collected. Such information is crucial for understanding the context and limitations of each Dataset Type. For contemporary vegetation plots, sampling involves standardised plot inventories and surveys that capture detailed vegetation characteristics across various regions. Fossil pollen data are collected from sediment records from numerous different depositional environments representing past vegetation and climate dynamics. Therefore, information on sampling methods is only available for both `vegetation_plot` and `fossil_pollen_archive` `Datasets`, providing metadata that ensures accurate and contextually relevant analyses.

```{r}
#| label: Dataset Sampling method variables scheme structure
#| tbl-cap: "Column names and types for table SamplingMethodID."
data_comments_sampling_method <-
  tibble::tribble(
    ~column_name, ~description,
    "sampling_method_id", "ID of a Dataset Sampling Method (unique)",
    "sampling_method_details", "Text description of individual Dataset Sampling Methods"
  )

get_db_table_data_types(
  con,
  "SamplingMethodID"
) %>%
  dplyr::full_join(
    data_comments_sampling_method,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset Sampling method Reference variables scheme structure
#| tbl-cap: "Column names and types for table SamplingMethodReference."
data_comments_sampling_method_reference <-
  tibble::tribble(
    ~column_name, ~description,
    "sampling_method_id", "ID of a Dataset Sampling Method",
    "reference_id", "ID of a Reference"
  )

get_db_table_data_types(
  con,
  "SamplingMethodReference"
) %>%
  dplyr::full_join(
    data_comments_sampling_method_reference,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset Sampling method scheme structure
include_graphics_absolute_path(
  here::here(
    "Outputs/Figures/website/DB_scheme_visualisation/SamplingMethodID.png"
  )
)
```

```{r}
#| label: Dataset Sampling method - plots
n_sampling_methods_per_dataset_type <-
  dplyr::inner_join(
    dplyr::tbl(con, "Datasets"),
    dplyr::tbl(con, "SamplingMethodID"),
    by = "sampling_method_id"
  ) %>%
  dplyr::inner_join(
    dplyr::tbl(con, "DatasetTypeID"),
    by = "dataset_type_id"
  ) %>%
  dplyr::distinct(dataset_type, sampling_method_details) %>%
  dplyr::group_by(dataset_type) %>%
  dplyr::count(name = "N") %>%
  dplyr::collect() %>%
  dplyr::ungroup()

fig_n_sampling_methods_per_dataset_type <-
  plot_waffle(
    n_sampling_methods_per_dataset_type,
    dataset_type,
    plot_title = "Number of Sampling Method per Datasets Type",
    one_point_is = 1
  ) +
  ggplot2::scale_fill_manual(
    values = palette_dataset_type
  )

save_figure_to_render(fig_n_sampling_methods_per_dataset_type)
```

#### Dataset References (`DatasetReferences`)

To support robust and transparent scientific research, each `Dataset` in **VegVault** can have multiple references at different levels. The `Dataset` `Source-Type`, `Dataset Source`, and `Sampling Method` can all have their own references, providing detailed provenance and citation information. This multi-level referencing system enhances the traceability and validation of the data. Each dataset can also have one or more direct references to specific data, further ensuring that users can accurately cite and verify the sources of their data. 

```{r}
#| label: Dataset reference variables scheme structure
#| tbl-cap: "Column names and types for table DatasetReferences."
data_comments_dataset_references <-
  tibble::tribble(
    ~column_name, ~description,
    "dataset_id", "ID of a Dataset",
    "reference_id", "ID of a Reference"
  )

get_db_table_data_types(
  con,
  "DatasetReferences"
) %>%
  dplyr::full_join(
    data_comments_dataset_references,
    by = "column_name"
  ) %>%
  tinytable::tt()
```

```{r}
#| label: Dataset reference method scheme structure
include_graphics_absolute_path(
  here::here(
    "Outputs/Figures/website/DB_scheme_visualisation/DatasetReference.png"
  )
)
```

This means that one dataset can have one/several references from each of those parts. Let's take a look at an example of what that could mean in practice.

```{r}
#| label: Dataset reference example
dataset_ref_example <-
  dplyr::tbl(con, "Datasets") %>%
  dplyr::filter(dataset_id == sel_dataset_for_example) %>%
  dplyr::inner_join(
    dplyr::tbl(con, "DatasetSourceTypeReference"),
    by = "data_source_type_id"
  ) %>%
  dplyr::left_join(
    dplyr::tbl(con, "References"),
    by = "reference_id"
  ) %>%
  dplyr::rename(
    source_type_ref = reference_detail
  ) %>%
  dplyr::select(-c(reference_id, mandatory)) %>%
  dplyr::left_join(
    dplyr::tbl(con, "SamplingMethodReference"),
    by = "sampling_method_id"
  ) %>%
  dplyr::left_join(
    dplyr::tbl(con, "References"),
    by = "reference_id"
  ) %>%
  dplyr::rename(
    sampling_method_ref = reference_detail
  ) %>%
  dplyr::select(-c(reference_id, mandatory)) %>%
  dplyr::left_join(
    dplyr::tbl(con, "DatasetSourcesReference"),
    by = "data_source_id"
  ) %>%
  dplyr::left_join(
    dplyr::tbl(con, "References"),
    by = "reference_id"
  ) %>%
  dplyr::rename(
    source_ref = reference_detail
  ) %>%
  dplyr::select(-c(reference_id, mandatory)) %>%
  dplyr::collect()
```

We have selected dataset ID: `r as.character(sel_dataset_for_example)`, which is a fossil pollen archive. Therefore, it has the reference of the *Dataset Source-Type*: 
 
 - *`r dataset_ref_example$source_type_ref`* 

and reference for the individual dataset: 

- *`r dataset_ref_example$source_ref`*